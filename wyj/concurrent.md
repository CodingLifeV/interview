<!-- TOC -->

- [Java并发](#java并发)
    - [1、 线程](#1-线程)
        - [1、多线程中的i++线程安全吗？为什么？](#1多线程中的i线程安全吗为什么)
        - [2、如何线程安全的实现一个计数器？](#2如何线程安全的实现一个计数器)
        - [3、多线程同步的方法](#3多线程同步的方法)
        - [4、介绍一下生产者消费者模式？](#4介绍一下生产者消费者模式)
        - [5、线程，进程，然后线程创建有很大开销，怎么优化？](#5线程进程然后线程创建有很大开销怎么优化)
        - [6、线程池运行流程，参数，策略](#6线程池运行流程参数策略)
        - [7、AQS](#7aqs)
        - [8、创建线程的方法，哪个更好，为什么？](#8创建线程的方法哪个更好为什么)
        - [9、Java中有几种方式启动一个线程？](#9java中有几种方式启动一个线程)
        - [10、什么是线程池？Java中有几种线程池？](#10什么是线程池java中有几种线程池)
        - [11、线程池有什么好处？](#11线程池有什么好处)
        - [12、cyclicbarrier和countdownlatch的区别](#12cyclicbarrier和countdownlatch的区别)
        - [13、如何理解Java多线程回调方法？](#13如何理解java多线程回调方法)
        - [14、概括的解释下线程的几种可用状态以及状态之间的关系](#14概括的解释下线程的几种可用状态以及状态之间的关系)
        - [15、同步方法和同步代码块的区别是什么？](#15同步方法和同步代码块的区别是什么)
        - [16、在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？](#16在监视器monitor内部是如何做线程同步的程序应该做哪种级别的同步)
        - [17、sleep() 和 wait() 有什么区别？](#17sleep-和-wait-有什么区别)
        - [18、同步和异步有何异同，在什么情况下分别使用他们？举例说明](#18同步和异步有何异同在什么情况下分别使用他们举例说明)
        - [19、设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1，使用内部类实现线程，对j增减的时候没有考虑顺序问题](#19设计4个线程其中两个线程每次对j增加1另外两个线程对j每次减少1使用内部类实现线程对j增减的时候没有考虑顺序问题)
        - [20、启动一个线程是用run()还是start()?](#20启动一个线程是用run还是start)
        - [21、请说出你所知道的线程同步的方法](#21请说出你所知道的线程同步的方法)
        - [22、stop()和suspend()方法为何不推荐使用？](#22stop和suspend方法为何不推荐使用)
        - [23、线程的sleep()方法和yield()方法有什么区别？](#23线程的sleep方法和yield方法有什么区别)
        - [24、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？](#24当一个线程进入一个对象的synchronized方法a之后其它线程是否可进入此对象的synchronized方法b)
    - [2、锁](#2锁)
        - [1、锁总结](#1锁总结)
        - [2、讲一下非公平锁和公平锁在reetrantlock里的实现](#2讲一下非公平锁和公平锁在reetrantlock里的实现)
        - [3、讲一下synchronized，可重入怎么实现](#3讲一下synchronized可重入怎么实现)
        - [4、锁和同步的区别](#4锁和同步的区别)
        - [5、什么是死锁(deadlock)？](#5什么是死锁deadlock)
        - [6、如何确保N个线程可以访问N个资源同时又不导致死锁？](#6如何确保n个线程可以访问n个资源同时又不导致死锁)
        - [7、ReentrantLock中公平锁和非公平锁在哪里体现的？](#7reentrantlock中公平锁和非公平锁在哪里体现的)
        - [8、volatile的实现原理](#8volatile的实现原理)

<!-- /TOC -->
# Java并发
## 1、 线程 
### 1、多线程中的i++线程安全吗？为什么？
* 如果i是局部变量（在方法里定义的），那么是线程安全的。因为局部变量是线程私有的，别的线程访问不到，其实也可以说没有线程安不安全之说，因为别的线程对他造不成影响。
* 如果i是全局变量（类的成员变量），那么是线程不安全的。因为如果是全局变量的话，同一进程中的不同线程都有可能访问到。
每个线程都有自己的工作内存，每个线程需要对共享变量操作时必须把共享变量从主内存中加载到自己的工作内存。等完成操作再保存到内存中。如果一个线程运算完成后还没刷到主内存中，另一个线程又对这个共享变量进行操作，那么读取到的数据就是脏数据了。
* 对于 i++ 这种线程不安全问题有以下几种解决方案：
  1. 对 i++ 操作的方法加同步锁，同时只能有一个线程执行 i++ 操作；
  2. 使用支持原子性操作的类，如 java.util.concurrent.atomic.AtomicInteger，它使用的是CAS 算法，效率优于第 1 种;

### 2、如何线程安全的实现一个计数器？
* 通过AtomicInteger类循环CAS操作

```java
private int count = 0;
private AtomicInteger atomicI = new AtomicInteger(0);

/**线程不安全的计数器*/
public void count(){
    count++;
}

/**线程安全的计数器，循环CAS*/
public void safeCount(){
    for(;;){
        int temp = atomicI.get();
        if(atomicI.compareAndSet(temp,++temp))
        break;
    }
}
```
* 通过关键字volatile和synchronized实现

```Java
public class AtomicCounter {
    private volatile int count = 0;

    public synchronized void increment() {
        count++;
    }
 
    public int getCount() {
        return count;
    }
}

```


### 3、多线程同步的方法
[参考](    https://www.cnblogs.com/XHJT/p/3897440.html)
1. 使用sychronized同步关键字修饰方法和代码块
2. 使用volatile修饰共享变量实现同步
3. 使用重入锁实现线程同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁，常用方法有：ReentrantLock() : 创建一个ReentrantLock实例 ； lock() : 获得锁；unlock() : 释放锁 
4. 使用局部变量实现线程同步。类ThreadLocal给每个线程绑定自己的值，实现每一个线程都有自己的共享变量。常用方法：
    1. ThreadLocal() : 创建一个线程本地变量 
    2. get() : 返回此线程局部变量的当前线程副本中的值 
    3. initialValue() : 返回此线程局部变量的当前线程的"初始值" 
    4. set(T value) : 将此线程局部变量的当前线程副本中的值设置为value
5. 使用阻塞队列实现线程同步。当队列满时，队列会阻塞插入元素的线程，队列为空时，获取元素的线程会阻塞直到等待队列变为空。发生阻塞的插入方法为put()，移除方法为take()。阻塞队列类似                     ArrayBlockingQueue、LinkedBlockingQueue。阻塞队列通常用来实现生产者和消费者模式。
6. 使用原子变量实现线程同步. 在java的util.concurrent.atomic包中提供了创建了原子类型变量的工具类，使用该类可以简化线程同步。 
AtomicInteger 表可以用原子方式更新int的值， AtomicInteger类常用方法：
   1. AtomicInteger(int initialValue) : 创建具有给定初始值的新的AtomicInteger
   2. addAddGet(int dalta) : 以原子方式将给定值与当前值相加
   3. get() : 获取当前值

### 4、介绍一下生产者消费者模式？
生产者和消费者模式是通过一个容器解决生存者和消费者的强耦合问题。生产者和消费者之间不直接通信，而是通过阻塞队列来进行通信，所以生产者生产完数据之后不用等待消费者来处理，而是直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列相当于一个缓冲区，平衡了生产者和消费者的处理能力。

Java中的线程池实际就是一种生产者和消费者模式的实现方式，生产者把任务丢给线程池，线程池创建线程并处理任务，如果将要运行的任务数大于线程池的基本线程数就把任务扔到阻塞队列里面，这种做法比使用一个阻塞队列实现生产者和消费者模式要好的多，因为消费者能够处理直接就处理掉了，这样速度更快，而生产者先存，消费者再取这种方式显然要慢一些。

### 5、线程，进程，然后线程创建有很大开销，怎么优化？
进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。

线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。

使用线程池进行优化。


### 6、线程池运行流程，参数，策略
* 处理流程：
首先判断核心线程池里的线程是否都在执行任务，如果不是则直接从核心线程池中创建一个线程来执行，如果都在忙则判断任务队列是否也满了，没满的话将任务放进去等待执行，满了就判断线程池的全部线程是否都在忙，如果都在忙就交给饱和策略来处理，否则就创建一个线程来帮助核心线程处理任务。
* 参数：
  1. corePoolSize:核心线程池大小
  2. MaximumPoolSize：线程池允许创建的最大线程数，如果使用无界队列该参数无效
  3. ThreadFactory：线程工厂，主要用来创建线程
  4. runnableTaskQueue：任务队列，用于保存等待执行的任务的阻塞队列
  5. RejectedExecutionHandler：饱和策略
* 策略
  1. ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常（默认情况）
  2. ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。
  3. ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务4. ThreadPoolExecutor.CallerRunsPolicy：只用调用者所在线程来运行任务

### 7、AQS
[参考](https://www.jianshu.com/p/da9d051dcc3d)

* AQS全称为AbstractQueuedSynchronizer,是并发容器中的同步器，它是抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类都依赖它，如ReentrantLock、Semaphore、CyclicBarrier、Condition、FutureTask等


* AQS的实现依赖内部的同步队列（FIFO双向队列）， 维护了一个volatile int类型的变量state，用来表示当前同步状态，如果当前线程获取同步状态失败，AQS会将该线程以及等待状态等信息构造成一个Node，将其加入同步队列的尾部，同时阻塞当前线程，当同步状态释放时，唤醒队列的头节点


* 获取锁：AQS中维护了一个同步状态status来计数重入次数，status初始值为0。当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。


* state的访问方式有三种, 这三种叫做均是原子操作，其中compareAndSetState的实现依赖于Unsafe的compareAndSwapInt()方法:
  1. getState()
  2. setState()
  3. compareAndSetState()


* AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）


* 不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：
  1. tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。
  2. tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。
  3. tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
  4. tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。

* acquire(int)
  * 流程：
    1. 调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；
    2. 没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；
    3. acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false
    4. 如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上
  * 其它方法：
    1. addWaiter(Node)：该方法用于将当前线程根据不同的模式（Node.EXCLUSIVE互斥模式、Node.SHARED共享模式）加入到等待队列的队尾，并返回当前线程所在的结点。如果队列不为空，则以通过compareAndSetTail方法以CAS的方式将当前线程节点加入到等待队列的末尾。否则，通过enq(node)方法初始化一个等待队列，并返回当前节点
    2. enq(node)用于将当前节点插入等待队列，如果队列为空，则初始化当前队列。整个过程以CAS自旋的方式进行，直到成功加入队尾为止
    3. acquireQueued(Node, int) 用于队列中的线程自旋地以独占且不可中断的方式获取同步状态（acquire），直到拿到锁之后再返回
      ```java
      public final void acquire(int arg) {
            if (!tryAcquire(arg) &&
                acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
                selfInterrupt();
      }
    ```
* release(int)：独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义，当然不仅仅只限于unlock()。

  正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false
  
  release(int)源码如下：
    ```Java
    public final boolean release(int arg) {
            if (tryRelease(arg)) {
                Node h = head;
                if (h != null && h.waitStatus != 0)
                    unparkSuccessor(h);//唤醒等待队列中下一个线程
                return true;
            }
            return false;
    }
    ```
### 8、创建线程的方法，哪个更好，为什么？
1. 继承Thread类（真正意义上的线程类），是Runnable接口的实现。
2. 实现Runnable接口，并重写里面的run方法。
3. 使用Executor框架创建线程池。

一般情况下，常见的是第二种Runnable接口有如下好处：
1. 避免点继承的局限，一个类可以继承多个接口；
2. 适合于资源的共享

### 9、Java中有几种方式启动一个线程？
第一种:继承Thread类,重写run方法.第二种:实现Runable接口,重写run方法

### 10、什么是线程池？Java中有几种线程池？

* 线程池是存储线程的容器,线程事先创建好后放入线程池,当有任务需要执行时,直接从线程池拿空闲线程使用,使用完毕后归还给线程池

* ThreadPoolExcutor有以下三种：
  1. FixedThreadPool ：创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中,使用LinkedBlockingQueue作为线程池的工作队列；
  2. SingleThreadExecutor ：创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行，使用LinkedBlockingQueue作为线程池的工作队列；
  3. CachedThreadPool ：创建一个可缓存线程池， 如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程
* ScheduledThreadPoolExecutor有以下二种：
  1. ScheduledThreadPoolExecutor：适用于需要多个后台线程执行周期任务，包含若干个线程
  2. SingleThreadScheduledExecutor：适用于需要一个后台线程执行周期任务，只包含一个线程，同时需要保证顺序的执行各个任务的应用场景

### 11、线程池有什么好处？
1. 降低资源消耗，通过重复利用已经创建的线程降低线程创建和销毁造成的消耗
2. 提高响应速度，当任务达到时，任务可以不需要的等到线程创建就能够立即执行
3. 提高线程的可管理性，性程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，故使用线程池可以进行统一的分配，调用和监控，但是也要做到合理的利用线程池，所以要对线程池的原理了如指掌

### 12、cyclicbarrier和countdownlatch的区别
1. CountdownLatch阻塞主线程，等所有子线程完结了再继续下去，其计数器只能使用一次
2. Syslicbarrier阻塞一组线程，直至某个状态之后再全部同时执行，并且所有线程都被释放后，还能通过reset来重用

### 13、如何理解Java多线程回调方法？
客户程序C调用服务程序S中的某个方法A，然后S又在某个时候反过来调用C中的某个方法B，对于C来说，这个B便叫做回调方法。

### 14、概括的解释下线程的几种可用状态以及状态之间的关系
1. 新建状态(New)：线程实例化后还从未执行start()方法时的状态；
2. 就绪状态(Runnable)：调用线程的start()方法启动线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。
处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由Java运行时系统的线程调度程序(thread scheduler)来调度的。
3. 运行状态(Running)： 当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法
4. 阻塞状态(Blocked)：出现在某一个线程等待锁的时候。 所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态
5. 死亡状态(Dead)： 有两个原因会导致线程死亡：
   1. run方法正常退出而自然死亡，
   2. 一个未捕获的异常终止了run方法而使线程猝死。

创建线程通过start方法进入就绪状态，获取cpu的执行权进入运行状态，失去cpu执行权会回到就绪状态，运行状态完成进入消亡状态，运行状态通过sleep方法和wait方法进入阻塞状态，休眠结束或者通过notify方法或者notifyAll方法释放锁进入就绪状态。

### 15、同步方法和同步代码块的区别是什么？
1. 语法不同，同步方法写在方法上
2. 同步块需要注明锁定对象，同步方法默认锁定this
3. 在静态方法中，都是默认锁定类对象
4. 在考虑性能方面，最好使用同步块来减少锁定范围提高并发效率。

### 16、在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？

* JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。本质都是对一个对象的监视器（monitor）进行获取，而这个获取过程是排他的，也就是同一时刻只能有一个线程获取到由synchronized所保护对象的监视器

* 代码块同步是使用monitorenter和monitorexit指令实现的。monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。

* java 还提供了显式监视器(Lock)和隐式监视器(synchronized)两种锁方案

### 17、sleep() 和 wait() 有什么区别？

1. sleep方法没有释放锁，但是wait方法释放了锁，使得其他线程可以使用同步控制块
2. sleep可以在任何地方使用，wait notify notifyall只能使用在同步控制块中
3. sleep必须捕获异常，其他不需要
4. sleep方法是Thread的静态方法，wait方法是Object类的普通方法

### 18、同步和异步有何异同，在什么情况下分别使用他们？举例说明

同步是安全的，异步是不安全的。同步是发送一个请求，等待返回，然后在发送一个请求。异步是发送一个请求，不用等待，随时可发送下一个请求

如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。

当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。

B-S模式中，使用Form表单提交数据，发送的就是同步请求，当响应返回后，才可以继续操作；

B-S模式中，使用Ajax向服务器端发送异步请求，在响应没有返回客户端时，客户端可以继续操作，当响应返回客户端后，就能显示结果

### 19、设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1，使用内部类实现线程，对j增减的时候没有考虑顺序问题

```java
public class ManyThreads {

    private int j;

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        ManyThreads many = new ManyThreads();
        Inc inc = many.new Inc();
        Dec dec = many.new Dec();
        for (int i = 0; i < 2; i++) {
            Thread t = new Thread(inc);
            t.start();
            t = new Thread(dec);
            t.start();
        }
    }

    private synchronized void inc() {
        j++;
        System.out.println(Thread.currentThread().getName() + "inc" + j);
    }

    private synchronized void dec() {
        j--;
        System.out.println(Thread.currentThread().getName() + "dec" + j);
    }

    class Inc implements Runnable {
        @Override
        public void run() {
            // TODO Auto-generated method stub
            for (int i = 0; i < 20; i++) {
                inc();
            }
        }
    }

    class Dec implements Runnable {
        @Override
        public void run() {
            // TODO Auto-generated method stub
            for (int i = 0; i < 20; i++) {
                dec();
            }
        }
    }
}
```

### 20、启动一个线程是用run()还是start()?
启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。

### 21、请说出你所知道的线程同步的方法
1. sychronized同步方法，同步代码块
2. wait()和notify()。wait():使一个线程处于等待状态，并且释放所持有的对象的lock;notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级
3. sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常
4. Lock接口的ReentranLock，通过lock()获取锁和unlock()释放锁，Condition对象中的await()和signal()类似于wait()和notify()方法
5. ThreadLocal为每一个线程绑定自己的私有数据；
6. volatile使变量在多个线程间可见。


### 22、stop()和suspend()方法为何不推荐使用？

* stop()方法停止线程释放锁将会给数据造成不一致的结果，如果在同步块执行一半时，stop来了，后面还没执行完呢，锁没了，线程退出了，别的线程又可以操作你的数据了，所以就是线程不安全了。
* suspend()方法暂停线程，使用resume()方法恢复线程的执行，如果使用不恰当，容易造成公共的同步对象的独占，发生死锁；也容易发生因为线程的暂停而导致数据不同步的情况。 

### 23、线程的sleep()方法和yield()方法有什么区别？
yield()：放弃当前CPU资源，将它让给其它的任务去占用CPU执行时间。但放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片。
1. sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；
2. 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；
3. sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；

### 24、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？

不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。

## 2、锁
### 1、锁总结
[参考美团技术团队](https://tech.meituan.com/2018/11/15/java-lock.html)
![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7f749fc8.png)

**1. 乐观锁 VS 悲观锁**

JDBC编程笔记中有总结

**2. 自旋锁 VS 适应性自旋锁**

> 阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。

* 自旋锁：
请求锁的线程不放弃CPU的执行时间进行自旋操作。
在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。
自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源


* 自适应的自旋锁（适应性自旋锁）：
自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。

**3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁**

jdk1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。

>偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。

![](https://ws1.sinaimg.cn/large/d4556b75ly1g3ny0kv6tyj20jw065myt.jpg)
* java对象头
  
  synchronized用的锁是存在Java对象头里的。synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的。Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）
  * Mark Word ：默认存储对象的HashCode，分代年龄和锁标志位信息
  * Klass Pointer ：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例
* Moniter

  Monitor是线程私有的数据结构，每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用
* 无锁

  无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。CAS原理及应用即是无锁的实现
* 偏向锁
  * 概念：
  指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。
  * 介绍：
  当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。
* 轻量级锁
  * 概念：
  是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。
  * 介绍：
    * 在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。
     * 拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。
    * 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。
    * 如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。
    * 若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。
* 重量级锁

  升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。

**4. 公平锁 VS 非公平锁**
>公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。
* 公平锁
  * 概念 ：多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁
  * 优点：等待锁的线程不会饿死
  * 缺点：整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大
* 非公平锁
  * 概念 ：多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景
  * 优点：可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程
  * 缺点：处于等待队列中的线程可能会饿死，或者等很久才会获得锁
* ReentrantLock
  * ReentrantLock实现代码如下：
![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/6edea205.png)
ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLoc默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。
  * 公平锁与非公平锁的lock()方法唯一的区别：
就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()，主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false
![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/bc6fe583.png)

  * lock方法对比非公平锁， 新来的线程没有插队的机会， 所有来的线程必须扔到队列尾部， acquire方法也会像非公平锁一样首先调用tryAcquire插队试试，但是只有队列为空或着本身就是head，那么才可能成功，如果队列非空那么肯定被扔到队列尾部去了。

**5. 可重入锁 VS 非可重入锁**
* 可重入锁
  * 概念：是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞
  * 优点：一定程度上可以避免死锁
 
**6. 独享锁 VS 共享锁**
* 独享锁：也叫排他锁，是指该锁一次只能被一个线程所持有，如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁
* 共享锁：该锁可被多个线程所持有，如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁
* ReentrantReadWriteLock
下图为ReentrantReadWriteLock的部分源码：
![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/762a042b.png)
由代码可知：ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，ReadLock和WriteLock是靠内部类Sync实现的锁。读锁是共享锁，写锁是独享锁，读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥
ReentrantReadWriteLock中的state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。

**7. AQS**

笔记中有总结

### 2、讲一下非公平锁和公平锁在reetrantlock里的实现
[参考](https://blog.csdn.net/lsgqjh/article/details/63685058)

非公平锁: 当线程争夺锁的过程中，会先进行一次CAS尝试获取锁，若失败，则进入acquire(1)函数，进行一次tryAcquire再次尝试获取锁，若再次失败，那么就通过addWaiter将当前线程封装成node结点加入到Sync队列，这时候该线程只能乖乖等前面的线程执行完再轮到自己了。

公平锁: 当线程在获取锁的时候，会先判断Sync队列中是否有在等待获取资源的线程。若没有，则尝试获取锁，若有，那么就那么就通过addWaiter将当前线程封装成node结点加入到Sync队列中。

### 3、讲一下synchronized，可重入怎么实现
实现方法是为每个锁关联一个线程持有者Moniter和计数器status，当计数器为0时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为0，则释放该锁。

### 4、锁和同步的区别

1. Lock是一个接口，而synchronized是Java中的关键字
2. synchronized是内置的语言实现，synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定，但是使用Lock则不行，lock是通过代码实现的，要保证锁定一定会被释放，就必须将 unLock()放到finally{} 中
3. Lock可以让等待的线程响应中断，线程可以去做别的事情；synchronized不行，等待的线程会一直等下去，不能够响应中断
4. Lock可以知道是否获取到锁，知道锁的状态，而synchronized却无法办到
5. Lock可以提高多个线程进行读操作的效率。

### 5、什么是死锁(deadlock)？

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。
死锁产生有四个必要条件，打破任意一个，就能打破死锁状态:
1. 互斥条件: 一个资源每次只能被一个进程使用 
2. 请求与保持: 一个进程因请求资源而阻塞时，对已获得的资源保持不放 
3. 不剥夺: 进程已获得的资源，在末使用完之前，不能强行剥夺 
4. 循环等待: 若干进程之间形成一种头尾相接的循环等待资源关系

### 6、如何确保N个线程可以访问N个资源同时又不导致死锁？

死锁产生有四个必要条件，打破任意一个，就能打破死锁状态:
互斥条件、请求与保持、不剥夺和循环等待。

1. 指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。 缺点：需要手动对锁的获得顺序进行分析
2. 指定加锁时限：线程指定超时时间，若无法获得锁的占用权，进行回退操作，并释放已占用的锁，经一段延时后再尝试进行任务。缺点 ：线程过多的话，可能造成频繁回退，运行效率不高。
3. 死锁检测：将线程和已获得锁的情况记录下来，定时检测是否所有死锁现象（线程循环等待现象），回退处于死锁状态的线程，延时后，重试这些线程，与添加加锁时限类似，缺点也同。


### 7、ReentrantLock中公平锁和非公平锁在哪里体现的？
lock方法对比非公平锁， 没有了if else 也就意味着新来的线程没有插队的机会， 所有来的线程必须扔到队列尾部， acquire方法也会像非公平锁一样首先调用tryAcquire插队试试，但是只有队列为空或着本身就是head，那么才可能成功，如果 队列非空那么肯定被扔到队列尾部去了。

### 8、volatile的实现原理

[Java并发编程：volatile关键字解析](https://www.cnblogs.com/dolphin0520/p/3920373.html)

synchronized是一个重量级的锁，虽然JVM对它做了很多优化，而volatile则是轻量级的synchronized

指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性，也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性。

**volatile有两层语义：**
1. 保证可见性、不保证原子性
   >可见性：对一个 volatile 变量的读，总能看到（任意线程）对这个 volatile 变量最后的写入
   
   >原子性：对任意单个 volatile 变量的读/写具有原子性，但类似于 volatile++ 这种符合操作不具有原子性。
2. 禁止指令重排序

**volatile 写-读内存语义：**

1. 当写一个 volatile 变量时，JVM 会把该线程对应的本地内存中的共享变量值刷新到主内存。
2. 当读一个 volatile 变量时，JVM 会把该线程对应的本地内存值置为无效，线程接下来从主内存中读取共享变量值。

**volatile 重排序规则：**

1. volatile 写之前的操作不会被编译器重排序到 volatile 写之后；
2. volatile 读之后的操作不会被编译器重排序到 volatile 读之前；
3. 第一个操作是 volatile 写，第二个操作是 volatile 读时，不能重排序。

![image](https://gitee.com/chenssy/blog-home/raw/master/image/201905/201905161002.png)

加入volatile关键字时，会多出一个lock前缀指令，
lock前缀指令实际上相当于一个内存屏障（内存栅栏），内存屏障会提供3个功能：
1. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
2. 它会强制将对缓存的修改操作立即写入主存；
3. 如果是写操作，它会导致其他CPU中对应的缓存行无效。

**通常来说，使用volatile必须具备以下2个条件：**
1. 对变量的写操作不依赖于当前值
2. 该变量没有包含在具有其他变量的不变式中

**volatile场景：**
1. 状态标记量
2. double check，单例模式下的双重检查



