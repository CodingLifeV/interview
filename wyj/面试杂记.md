<!-- TOC -->

- [笔试面试记录](#笔试面试记录)
  - [&、&&、|、||、^、<<、>>、~、>>>等运算符](#^等运算符)
    - [按位与 &](#按位与-)
    - [逻辑与 &&](#逻辑与-)
    - [按位或 |](#按位或-)
    - [逻辑或 ||](#逻辑或-)
    - [异或运算符 ^](#异或运算符-^)
    - [左移运算符 <<](#左移运算符-)
    - [右移运算符 >>](#右移运算符-)
    - [取反运算符 ~](#取反运算符-)
    - [无符号右移运算符 >>>](#无符号右移运算符-)
  - [Java 基本数据类型](#java-基本数据类型)
  - [100 万个商家，ID 号是顺序的，但是其中有两个 ID 丢失了，问怎样快速的找到丢失的 ID？](#100-万个商家id-号是顺序的但是其中有两个-id-丢失了问怎样快速的找到丢失的-id)

<!-- /TOC -->

# 笔试面试记录

## &、&&、|、||、^、<<、>>、~、>>>等运算符

[Java &、&&、|、||、^、<<、>>、~、>>>等运算符](https://cloud.tencent.com/developer/article/1338265)

### 按位与 &

& 按位与的运算规则是将两边的数转换为二进制位，然后运算最终值，运算规则即(**两个为真才为真**) 1 & 1=1， 1 & 0=0， 0 & 1=0，0 & 0=0；

**问题：如何通过 & 运算判断一个数是 2 的幂次方**

减 1 后与自身进行按位与，如果结果为 0，表示这个数是 2 的 n 次幂

如果一个数不是 2 的幂次方，那么每次减 1 后与自身进行按位与，会将低位的 1 变为 0，可以用来判断一个数中二进制中 1 的个数。

按位与还可以判断一个是是否为奇数，自身与 1 做按位与，如果结果为 1，则为奇数

### 逻辑与 &&

短路逻辑与，先运算 && 左边的表达式，一旦为假，后续不管多少表达式，均不再计算，一个为真，再计算右边的表达式，两个为真才为真。

### 按位或 |

| 按位或和 & 按位与计算方式都是转换二进制再计算，不同的是运算规则(**一个为真即为真**)，1 | 0 = 1， 1 | 1 = 1， 0 | 0 = 0， 0 | 1 = 1；

### 逻辑或 ||

逻辑或 || 的运算规则是一个为真即为真，后续不再计算，一个为假再计算右边的表达式

### 异或运算符 ^

^ 异或运算符顾名思义，异就是不同，其运算规则为**不同则为 1，相同则为 0**，1 ^ 0 = 1，1 ^ 1 = 0，0 ^ 1 = 1， 0 ^ 0 = 0；

### 左移运算符 <<

5 << 2 的意思为 5 的二进制位往左挪两位，右边补 0，5 的二进制位是 0000 0101 ， 就是把有效值 101 往左挪两位就是 0001 0100 ，正数左边第一位补 0，负数补 1，**等于乘于 2 的 n 次方**，十进制位是 20

### 右移运算符 >>

5 的二进制位是 0000 0101，右移两位就是把 101 左移后为 0000 0001，正数左边第一位补 0，负数补 1，**等于除于 2 的 n 次方**，结果为 1

### 取反运算符 ~

**取反就是 1 为 0，0 为 1**

### 无符号右移运算符 >>>

无符号右移运算符和右移运算符的主要区别在于负数的计算，因为无符号右移是高位补 0，移多少位补多少个 0。

## Java 基本数据类型

![image](https://ws1.sinaimg.cn/large/d4556b75ly1g3mteb1k1kj20l00eidgb.jpg)

## 100 万个商家，ID 号是顺序的，但是其中有两个 ID 丢失了，问怎样快速的找到丢失的 ID？

**一个 ID 丢失方法：**

1^1=0，2^2=0，n^n=0，k^0=k；所以如果我们把这 n-1 个 ID 号异或起来，再来异或一下 1，2，...，n 个 ID。那么最终的答案肯定是丢失的 ID 号

**二个 ID 丢失的情况：**

对这 N 个数和 N-2 个数进行异或运算，所以根据异或的结果 1 所在的最低位，把数字分成两半，每一半里都还有只出现一次的数据和成对出现的数据。这样继续对每一半相异或则可以分别求出两个只出现一次的数字
