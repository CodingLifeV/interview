<!-- TOC -->

- [数据库](#数据库)
    - [1、SQL基础](#1sql基础)
        - [0、数据库基本操作](#0数据库基本操作)
        - [1、写SQL：找出每个城市的最新一条记录。](#1写sql找出每个城市的最新一条记录)
        - [2、一个学生表，一个课程成绩表，怎么找出学生课程的最高分数](#2一个学生表一个课程成绩表怎么找出学生课程的最高分数)
        - [3、有一组合索引（A,B,C），会出现哪几种查询方式？tag:sql语句](#3有一组合索引abc会出现哪几种查询方式tagsql语句)
    - [2、JDBC基础](#2jdbc基础)
        - [1、数据库水平切分，垂直切分](#1数据库水平切分垂直切分)
        - [2、数据库两种引擎以及区别？介绍一下什么时候用Innodb什么时候用MyISAM。为什么查询操作MyISAM比Innodb快？](#2数据库两种引擎以及区别介绍一下什么时候用innodb什么时候用myisam为什么查询操作myisam比innodb快)
        - [3、数据库索引介绍一下。主键和索引的区别？](#3数据库索引介绍一下主键和索引的区别)
        - [4、索引了解嘛，底层怎么实现的，什么时候会失效，索引使用的注意点](#4索引了解嘛底层怎么实现的什么时候会失效索引使用的注意点)
        - [5、数据库的隔离级别](#5数据库的隔离级别)
        - [6、数据库乐观锁和悲观锁](#6数据库乐观锁和悲观锁)
        - [7、数据库的三范式？](#7数据库的三范式)
        - [8、讲一下数据库ACID的特性？](#8讲一下数据库acid的特性)
        - [9、mysql主从复制？](#9mysql主从复制)
        - [10、leftjoin和rightjoin的区别？](#10leftjoin和rightjoin的区别)
        - [11、数据库优化方法](#11数据库优化方法)
        - [12、慢日志+explain查询分析SQL语句进行优化](#12慢日志explain查询分析sql语句进行优化)
        - [13、谈一下你对继承映射的理解。](#13谈一下你对继承映射的理解)
        - [14、说出数据连接池的工作机制是什么?](#14说出数据连接池的工作机制是什么)
        - [15、事务的ACID是指什么？](#15事务的acid是指什么)
        - [16、JDBC中如何进行事务处理？](#16jdbc中如何进行事务处理)
        - [17、SQL注入？](#17sql注入)
        - [18、索引为什么能查的快？为什么而需要索引？索引的优缺点？](#18索引为什么能查的快为什么而需要索引索引的优缺点)
        - [19、索引的底层使用什么实现的，为什么不用B树或者红黑树？](#19索引的底层使用什么实现的为什么不用b树或者红黑树)
        - [20、redo？undo？checkpoint？](#20redoundocheckpoint)
        - [21、mysql写数据的时候,需要先将数据写到buffer里,再写到磁盘里,万一MySQL这时候突然挂了,怎么办?](#21mysql写数据的时候需要先将数据写到buffer里再写到磁盘里万一mysql这时候突然挂了怎么办)
        - [22、where和 having by 区别](#22where和-having-by-区别)
        - [23、树总结](#23树总结)
    - [3、JDBC进阶](#3jdbc进阶)
        - [1、JDBC的反射，反射都是什么？](#1jdbc的反射反射都是什么)
        - [2、Jdo是什么?](#2jdo是什么)
        - [3、Statement和PreparedStatement有什么区别？哪个性能更好？](#3statement和preparedstatement有什么区别哪个性能更好)
        - [4、使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？](#4使用jdbc操作数据库时如何提升读取数据的性能如何提升更新数据的性能)

<!-- /TOC -->
# 数据库
## 1、SQL基础
[数据库强推文](https://blog.csdn.net/jack__frost/article/details/72571540)
### 0、数据库基本操作
* 创建数据库
`CREATE DATABASE <数据库名>；`
* 删除数据库
`DROP DATABASE <数据库名>;`
* 选择数据库
`USE <数据库名>；`
* 创建数据表
`CREATE TABLE [if not exists] table_name(column_name, column_type)`
* 删除数据表
`DROP TABLE table_name`
* 插入数据
`INSERT  INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN )`
* 查询数据
`SELETE column_name1,column_name2 FROM table_name [WHERE Clause][LIMIT N][OFFSET M]`
* where语句
`SELECT field1, field2,...fieldN FROM table_name [WHERE condition1 [AND [OR]] condition2.....`
* update更新
`UPDATE table_name SET field1=new-value1, field2=new-value2 [WHERE Clause]`
* delete语句
`DELETE FROM table_name [WHERE Clause]`
* Like子句
`SELECT field1, field2,...fieldN 
FROM table_name
WHERE field1 LIKE condition1 [AND [OR]] filed2 = 'somevalue'`
* union操作符
UNION 语句：用于将不同表中相同列中查询的数据展示出来；（不包括重复数据）
UNION ALL 语句：用于将不同表中相同列中查询的数据展示出来；（包括重复数据）
`SELECT expression1, expression2, ... expression_n
FROM tables [WHERE conditions]
UNION [ALL | DISTINCT]
SELECT expression1, expression2, ... expression_n
FROM tables [WHERE conditions];`
* order by排序
`SELECT field1, field2,...fieldN table_name1, table_name2...
ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC升序]]`
* group by分组
`SELECT column_name, function(column_name)
FROM table_name
WHERE column_name operator value
GROUP BY column_name;`
* inner join、left join、right join
`SELETE 表1数据，表2数据 FROM 表1 INNER JOIN/LEFT JIOIN/RIGHT JOIN 表2 ON 表1参数=表2参数`


[SQL教程](https://www.runoob.com/mysql/mysql-tutorial.html)
### 1、写SQL：找出每个城市的最新一条记录。 
select * , max(time) from table group by city
### 2、一个学生表，一个课程成绩表，怎么找出学生课程的最高分数
### 3、有一组合索引（A,B,C），会出现哪几种查询方式？tag:sql语句

## 2、JDBC基础
### 1、数据库水平切分，垂直切分
* 水平切分又称为Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。当一个表中的数据逐渐增多时，Sharding时必然的选择，它可以将数据分布到集群的不同结点上，从而缓解单个数据库的压力。适合具有超大表的系统。

* 垂直拆分:专库专用。一个数据库由很多表的构成，每个表对应着不同的业务，垂直切分是指按照业务将表进行分类，分布到不同的数据库上面，这样也就将数据或者说压力分担到不同的库上面。通常按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用得分列切分到不同的表中。适合各业务之间耦合度非常低的系统。

### 2、数据库两种引擎以及区别？介绍一下什么时候用Innodb什么时候用MyISAM。为什么查询操作MyISAM比Innodb快？

**B+Tree索引**

[B+Tree树、B树参考文章](https://blog.csdn.net/qq_17612199/article/details/50944413)

**MyISAM索引实现：**

[索引参考文章](http://blog.jobbole.com/24006/)

   MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。
![](https://ws1.sinaimg.cn/large/d4556b75gy1g3sfr051ruj20mg0f8gmt.jpg)

   MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。
   
   ![](https://ws1.sinaimg.cn/large/d4556b75gy1g3sfrtg9mzj20ju0fit9w.jpg)
   
   因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。

**InnoDB索引实现：**

   InnoDB的B+Tree索引分为主索引和辅助索引。主索引的叶子节点data域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在二个不同的地方，所以一个表只能有一个聚簇索引。
![](https://ws1.sinaimg.cn/large/d4556b75ly1g3sftjjb0ij20ll093jsd.jpg)

   辅助索引的叶子节点的data域记录着主键的值，因此在使用辅助索引进行查找时，需要先找到主键值，然后再到主索引中进行查找。
![](https://ws1.sinaimg.cn/large/d4556b75ly1g3sftouil5j20l108pt9o.jpg)

**如何选择:**
   1. 是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；
   2. 如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB
   3. 系统奔溃后，MyISAM恢复起来更困难，能否接受；
   4. MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。

**区别：**

1. 锁机制:MyISAM是表级锁，而InnoDB是行级锁；
2. 查询表的行数不同：MyISAM：select count( * ) from table,MyISAM只要简单的读出保存好的行数，注意的是，当count( * )语句包含   where条件时，两种表的操作是一样的；InnoDB中不保存表的具体行数，也就是说，执行select count( * ) from table时，InnoDB要扫描一遍整个表来计算有多少行；
3. 外键支持：mysiam表不支持外键，而InnoDB支持；
4. 事务处理：MyISAM是非事务安全型的，而InnoDB是事务安全型的（支持事务处理等高级处理）；
5. （3）select ,update ,insert ,delete：如果执行大量的SELECT，MyISAM是更好的选择
如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。

**为什么MyISAM会比Innodb的查询速度快：**

NNODB在做SELECT的时候，要维护的东西比MYISAM引擎多很多；
1. 数据块，INNODB要缓存，MYISAM只缓存索引块， 这中间还有换进换出的减少； 
2. innodb寻址要映射到块，再到行，MYISAM记录的直接是文件的OFFSET，定位比INNODB要快
3. INNODB还需要维护MVCC一致；虽然你的场景没有，但他还是需要去检查和维护
MVCC ( Multi-Version Concurrency Control )多版本并发控制 

### 3、数据库索引介绍一下。主键和索引的区别？
* 普通索引:
普通索引是MySQL中的基本索引类型，允许在定义索引的列中插入重复值和空值。
* 唯一索引:
MySQL数据库索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
* 主键索引:
它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引
* 全文索引:
全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找，用于查找文本中的关键词。全文索引可以在CHAR、VARCHAR或者TEXT类型的列上创建。
* 聚集索引:
表数据按照索引的顺序来存储的，当在表中插入一行数据时，这行数据的存放的顺序（物理顺序）和建立索引的键值的逻辑顺序相同。 一个表只能包含一个聚集索引。
* 非聚簇索引:
表数据存储顺序与索引顺序无关，当在表中插入一行数据时，这行数据存放的顺序（物理顺序）在表的最后，不会影响数据表中原有的存储顺序。一个表中可以创建多个非聚集索引，一个表最多可以创建249个非聚集索引。
* 联合索引:
将一张表中多个列组成联合索引(col1,col2,col3)，其生效方式满足最左前缀原则。
* 哈希索引:
哈希索引可以以O(1)时间进行查找，但是失去了有序性；
InnoDB存储引擎有一个特殊的功能叫"自适应哈希索引"，当某个索引值使用的非常频繁时，会在B+Tree索引上在创建一个哈希索引，这就让B+Tree索引具有哈希索引的一些优点，比如快速的哈希查找
* 空间数据索引:
空间索引是对空间数据类型的字段建立的索引。
* 聚集索引和非聚簇索引区别与联系：
聚簇索引和非聚簇索引都是用B+树实现的。但是聚簇索引中叶子节点存储的是一条完整的记录数据，非聚簇索引的叶子节点中存储的是指向主键的引用。
* 主键和索引的区别：
1. 主键一定是唯一性索引，唯一性索引并不一定就是主键
2. 一个表中可以有多个唯一性索引，但只能有一个主键
3. 主键列不允许空值，而唯一性索引列允许空值
4. 主键可以被其他字段作外键引用，而索引不能作为外键引用

[索引参考文章1](https://www.cnblogs.com/maybechen/p/8580542.html)

[索引参考文章2](https://blog.csdn.net/jack__frost/article/details/72571540)

[数据库强推文](https://blog.csdn.net/jack__frost/article/details/72571540)

### 4、索引了解嘛，底层怎么实现的，什么时候会失效，索引使用的注意点

* B+树实现的。没有遵循最左匹配原则。 一些关键字会导致索引失效，例如 or，!=，not in，is null，is not null，like查询是以%开头，隐式转换会导致索引失效。 对索引应用内部函数，索引字段进行了运算。

* 索引使用注意点：
1. 一般说来，索引应建立在那些将用于JOIN,WHERE判断和ORDER BY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引
2. 最好不要给数据库留NULL，尽可能的使用NOT NULL填充数据库
3. 应尽量避免在 where 子句中使用 != 或 <> 操作符，否则将引擎放弃使用索引而进行全表扫描
4. 应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描
5. in 和 not in 也要慎用，否则会导致全表扫描
6. like %keyword 索引失效，使用全表扫描
7. 如果在 where 子句中使用参数，也会导致全表扫描
8. 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描
9. 在使用索引字段作为条件时，如果该索引是复合索引（多列索引），那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致

* 建立索引的原则：
1. 定义有主键的数据列一定要建立索引。因为主键可以加速定位到表中的某一行 
2. 定义有外键的数据列一定要建立索引。外键列通常用于表与表之间的连接，在其上创建索引可以加快表间的连接
3. 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的
4. 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间
5. 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度
6. 在经常需要搜索的列上，可以加快搜索的速度

[最左匹配原则介绍](https://www.jb51.net/article/142840.htm)

[索引使用注意](https://blog.csdn.net/jack__frost/article/details/72571540)

### 5、数据库的隔离级别
* 未提交读(Read Uncommitted)
事务中的修改，即使没有提交，对其它事务也是可见的。读取未提交的数据，也被称之为脏读。
* 提交读(Read Committed)
一个事务只能读取已经提交的事务所做的修改,即一个事务所做的修改在提交之前对其它事务是不可见的。已提交读隔离级别解决了脏读的问题，但是出现了不可重复读的问题。即事务A在两次查询的数据不一致，因为在两次查询之间事务B更新并提交了一条数据。
* 可重复读(repeatable read)
保证在同一个事务中多次读取同样数据的结果是一样的。
* 可串行化(Serializable)
强制事务串行执行。可串行化完全锁定字段，若一个事务来查询同一份数据就必须等待，直到前一个事务完成并解除锁定为止。是完整的隔离级别，会锁定对应的数据表格，因而会有效率的问题。

### 6、数据库乐观锁和悲观锁
* 悲观锁
总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。
* 乐观锁
总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。
* 两种锁的使用场景
乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。
* 乐观锁常见的两种实现方式

1. 版本号机制：

   一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。
2. CAS算法

   即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数：
   1. 需要读写的内存值 V
   2. 进行比较的值 A
   3. 拟写入的新值 B
 
   当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。
* 乐观锁的缺点
1. ABA问题
如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 "ABA"问题。
JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
2. 循环时间长开销大
自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 
3. 只能保证一个共享变量的原子操作
CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。
* CAS与synchronized的使用情景
简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）
1. 对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。
2. 对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。

[乐观锁悲观锁参考文章](https://blog.csdn.net/qq_34337272/article/details/81072874)

### 7、数据库的三范式？
1. 第一范式(确保每列保持原子性)：数据库表的每一列都是不可分割的基本数据项，所有字段值都是不可分解的原子值
2. 第二范式(确保表中的每列都和主键相关)：要求实体的属性完全依赖于主关键字。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。
3. 第三范式(确保每列都和主键列直接相关,而不是间接相关)：第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。

### 8、讲一下数据库ACID的特性？

1. 原子性：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚，回滚可以用回滚日志来实现

2. 一致性：~~数据库在事务执行前后都保持一致性状态，在一致性状态下，所有事务对一个数据的读取结果都是相同的。如果事务内有一个操作失败时，所有的更改过的数据都必须回滚到修改前的状态。~~
 
   一致性是指事务必须使数据库从一个一致性状态变成另一个一致性状态，也就是事务执行前后必须处于一致性状态。

   以转账为例，假设用户A和B两者的钱加起来是5000，那么不管A和B之间如何转账，转多少次，事务结束后两个用户的钱加起来应该还得是5000，这就是事务的一致性。

3. 隔离性：一个事务所做的修改在最终提交以前，对其它事务是不可见的。

4. 持久性：一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能

### 9、mysql主从复制？

* 主从复制：指数据从一个数据库服务器的主节点上复制到其他一个或多个从节点的数据库服务器。MySql数据库默认采用异步复制方式。从节点数据库不用一直访问主服务器也可以实现更新数据。
MySQL的主从复制并不是数据库磁盘上的文件直接拷贝，而是通过逻辑的binlog日志复制到要同步的服务器本地，然后由本地的线程读取日志里面的SQL语句重新应用到MySQL数据库中。
主要设计三个线程：
  1. binlog线程：负责将主服务器上的数据更改写入二进制（Binary log）中；
  2. I/O线程：负责从主服务器上读取二进制日志，并写入从服务器的重放（Replay log）中；
  3. SQL线程：负责读取重放日志并重放其中的SQL语句

* 读写分离：主服务器处理写操作以及实时性要求比较高的读操作，而从服务器负责读操作，读写分离提高性能的原因在于：
  1. 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
  2. 从服务器可以使用MyISAM，提升查询性能以及节约系统开销；
  3. 增加冗余，提高可用性
 读写分离常用代理方式来实现，代理服务器接受来自应用层传来的读写请求，然后决定转发到拿个服务器。

[主从复制参考文章](http://baijiahao.baidu.com/s?id=1598186201849829616&wfr=spider&for=pc)

### 10、leftjoin和rightjoin的区别？
left join(左联接)返回包括左表中的所有记录和右表中联结字段相等的记录；right join(右联接)返回包括右表中的所有记录和左表中联结字段相等的记录。
left保留左表的值，右表无值填null，right相反

[leftjoin和rightjoin参考文章](https://www.cnblogs.com/pcjim/articles/799302.html)

### 11、数据库优化方法
* 语句优化
要提高MySQL的更新/插入效率，应首先考虑降低锁的竞争，减少写操作的等待时间
1. insert语句
   1. 批量插入数据的时候，同时插入多条
   2. 将进程/线程数控制在2倍于CPU数目相对合适
   3. 采用顺序主键策略（例如自增主键，或者修改业务逻辑，让插入的记录尽可能顺序主键）
   4. 考虑使用replace语句代替insert语句。
2. delete语句
   1. 如果不考虑数据的恢复，可使用truncate table语句删除数据，删除了不记录mysql日志文件
   2. 如果没有外键关联，innodb执行truncate是先drop table(原始表),再创建一个跟原始表一样空表,速度要远远快于delete逐条删除行记录。如果表有外键关联，truncate table删除表数据为逐行删除
   3. 使用[optimize table](https://www.cnblogs.com/jimmy-muyuan/p/5874410.html)来优化表。truncate table删除表后，optimize table尤其重要，特别是大数据数据库，表空间可以得到释放
3. update语句
   1. 尽量不要修改主键字段
   2. 当修改VARCHAR型字段时，尽量使用相同长度内容的值代替
   3. 尽量最小化对于含有UPDATE触发器的表的UPDATE操作
   4. 避免UPDATE将要复制到其他数据库的列
   5. 避免UPDATE建有很多索引的列。
   6. 避免UPDATE在WHERE子句条件中的列
3. replace语句:
根据应用情况可以使用replace语句代替insert/update语句：
  使用REPLACE插入记录时，如果记录不重复（或往表里插新记录），REPLACE功能与INSERT一样，如果存在重复记录，REPLACE就使用新记录的值来替换原来的记录值，而UPDATE什么都不做。使用REPLACE的最大好处就是可以将DELETE和INSERT合二为一，形成一个原子操作。这样就可以不必考虑同时使用DELETE和INSERT时添加事务等复杂操作了。

* 查找优化
1. 是否向数据库请求了不需要的数据。也就是说不要轻易使用select * from ，能明确多少数据就查多少个
2. mysql是否扫描额外的纪录。查询是否扫描了过多的数据。最简单的衡量查询开销三个指标如下：响应时间；扫描的行数；返回的行数。这三个指标都会记录到mysql的[慢日志](https://www.cnblogs.com/sunss/p/6548588.html)中，所以检查慢日志记录是找出扫描行数过多的查询的好办法。
如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试下面的技巧去优化它：
   1. 使用索引覆盖扫描
   2. 改变库表结构。例如使用单独的汇总表。
   3. 重写这个复杂的查询。让mysql优化器能够以更优化的方式执行这个查询。
3. 设计查询的时候考虑是否需要将一个复杂的查询分成多个简单的查询。分解关联查询让缓存的效率更高。
4. 单表查询步步优化：
   1. 明确需要的字段，要多少就写多少字段
   2. 使用分页语句：limit start , count 或者条件where子句
   3. 如果是有序的查询，可使用ORDER BY
   4. 开启查询缓存
   5. 使用索引
5. 多表查询步步优化：
   1. 对查询进行优化，要尽量避免全表扫描
   2. 应尽量避免在where子句中对字段进行null值判断
   3. in 和 not in 也要慎用，否则会导致全表扫描
   4. 任何地方都不要使用 select * from t ，用具体的字段列表代替 *
   5. 在Join表的时候使用相同类型的例，并将其索引
   6. 尽量使用数字型字段，只含数值信息的字段尽量不要设计为字符型
* 索引优化
   1. 最左前缀匹配原则
   2. =和in可以乱序
   3. 尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count( * )
   4. 索引列不能参与计算，保持列“干净”
   5. 尽量的扩展索引，不要新建索引
   6. 定义有外键的数据列一定要建立索引
   7. 对于那些查询中很少涉及的列，重复值比较多的列不要建立索引
   8. 对于定义为text、image和bit的数据类型的列不要建立索引
   9. 对于经常存取的列避免建立索引
* 表的优化
1. 单表设计与优化
   1. 设计规范化表，消除数据冗余
   2. 适当的冗余，增加计算列，在数据冗余和处理速度之间找到合适的平衡点
   3. 索引的设计
   4. 主键和外键的必要性
   5. 存储过程、视图、函数的适当使用，有助于减少应用程序中SQL复制的弊端
   6. 分割你的表，减小表尺寸
   7. 字段设计原则：数据类型尽量用数字型不用字符型、数据类型尽量小、尽量不要允许NULL，除非必要，可以用NOT NULL+DEFAULT代替、少用TEXT和IMAGE，二进制字段的读写是比较慢的、自增字段要慎用，不利于数据迁移
2. 基于单表设计的多表设计原则
   1. 建立合适的表关系：一对一、一对多、多对一、多对多
   2. 适当的表拆分：水平拆分、垂直拆分

[数据库强推文](https://blog.csdn.net/jack__frost/article/details/72571540)

### 12、慢日志+explain查询分析SQL语句进行优化
通过开启慢日志功能来优化查询语句：

long_query_time     ： 设定慢查询的阀值，超出次设定值的SQL即被记录到慢查询日志，缺省值为10s

slow_query_log      ：  指定是否开启慢查询日志

log_slow_queries    ： 指定是否开启慢查询日志(该参数要被slow_query_log取代，做兼容性保留) 

slow_query_log_file ：  指定慢日志文件存放位置，可以为空，系统会给一个缺省的文件host_name-slow.log 

min_examined_row_limit：查询语句的执行行数检查返回少于该参数指定行的SQL不被记录到慢查询日志 

log_queries_not_using_indexes: 不使用索引的慢查询日志是否记录到索引

步骤：
1. 查看慢查询日志是否开启：SHOW VARIABLES LIKE '%slow_query_log%
2. 开启慢日志：SET GLOBAL slow_query_log=1
3. 查看慢查询日志阙值：SHOW GLOBAL VARIABLES LIKE '%long_query_time%
4. 设置慢查询日志阙值：SET GLOBAL long_query_time=3
5. 查看多少SQL语句超过了阙值：SHOW GLOBAL STATUS LIKE '%Slow_queries%
6. MySQL提供的日志分析工具mysqldumpslow，可以得到返回次数最多、访问次数最多的SQL语句等功能

[慢日志](https://www.cnblogs.com/sunss/p/6548588.html)

[慢日志+explain查询分析](https://blog.csdn.net/qq_35216516/article/details/80523773)

使用EXPLAIN关键字可以分析SELECT查询语句，通过分析EXPLAIN结果来优化查询语句。比较重要的字段：

|||||||||||
---|---|---|---|---|---|---|---|---|---|
id| select_type| table|type |possible_keys | key | key_len | ref | rows | Extra

1. select_type：查询中每个select子句的类型，有简单查询、联合查询、子查询
2. key：实际使用的索引
3. rows：扫描的行数
4. type：显示查询使用了何种类型。从最好到最差的连接类型为NULL、system、const、eq_ref、ref、range、index和ALL，得保证查询至少达到range级别，最好能达到ref。
   1. eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配；
   2. ref：非唯一性索引扫描，返回匹配某个单独值的所有行；
   3. range：只检索给定范围的行，使用一个索引来选择行；

### 13、谈一下你对继承映射的理解。
在面向对象的程序领域中，类与类之间是有继承关系的，但是在关系数据库的世界中，表与表之间没有任何关键字可以明确指明这两张表的父子关系，表与表是没有继承关系这样的说法的。为了将程序领域中的继承关系反映到数据中，Hibernate为我们提供了3中方案：
继承关系的映射策略有三种：
1. 每个继承结构一张表，不管多少个子类都用一张表。
2. 每个子类一张表，公共信息放一张表，特有信息放单独的表。
3. 每个具体类一张表，有多少个子类就有多少张表。

第一种方式属于单表策略，其优点在于查询子类对象的时候无需表连接，查询速度快，适合多态查询；缺点是可能导致表很大。后两种方式属于多表策略，其优点在于数据存储紧凑，其缺点是需要进行连接查询，不适合多态查询。

### 14、说出数据连接池的工作机制是什么?
1. 在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数；
2. 当应用程序向连接池请求的连接数超过最大连接数量时,这些请求将被加入到等待队列中。

### 15、事务的ACID是指什么？
### 16、JDBC中如何进行事务处理？
Connection的三个方法与事务有关：
1. setAutoCommit（boolean）：设置是否为自动提交事务，如果true（默认值为true）表示自动提交，也就是每条执行的SQL语句都是一个单独的事务，如果设置为false，那么相当于开启了事务了；con.setAutoCommit(false) 表示开启事务。
2. commit（）：提交结束事务。
3. rollback（）：回滚结束事务。

### 17、SQL注入？
* 概念：
所谓SQL注入，就是通过把SQL命令插入到Web表单或输入域名或页面请求的查询字符串中，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意的）SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。通过SQL语句，实现无帐号登录，甚至篡改数据库。
* 分类：
SQL注入可以分为平台层注入和代码层注入。前者由不安全的数据库配置或数据库平台的漏洞所致；后者主要是由于程序员对输入未进行细致地过滤，从而执行了非法的数据查询

* 举例：
比如在一个登录界面，如下输入可实现免帐号和密码登录：

    用户名 | 密码
    ---|---
    ‘or 1 = 1--  |

  点登陆,如若没有做特殊处理,那么这个非法用户就很得意的登陆进去了，why?

  从理论上说，后台认证程序中会有如下的SQL语句：
"SELECT * FROM user WHERE username=' "+username+" ' AND password=' "+password+" ' ";
当输入了上面的用户名和密码，上面的SQL语句变成：
SELECT * FROM user WHERE username=' ' or 1=1 -- AND password=' ';

  分析：Where语句后面的username=' ' or 1=1这个条件一定会成功；然后后面的--是注释符，它将后面的语句注释，所以语句永远都能正确执行，用户轻易骗过系统，获取合法身份。
如果是执行：SELECT * FROM user_table WHERE  username=' ' ;DROP DATABASE (DB Name) 
--' and password=' '将导致数据库被删除。

* 解决方法：
1. （简单又有效的方法）PreparedStatement
采用预编译语句集，它内置了处理SQL注入的能力，只要使用它的setXXX方法传值即可。
原理：sql注入只对sql语句的准备(编译)过程有破坏作用，而PreparedStatement已经准备好了，执行阶段只是把输入串作为数据处理，而不再对sql语句进行解析,准备,因此也就避免了sql注入问题. 
2. 使用正则表达式过滤传入的参数 
3. 字符串过滤
4. jsp中调用该函数检查是否包函非法字符，防止SQL从URL注入
5. JSP页面判断代码，使用javascript在客户端进行不安全字符屏蔽

### 18、索引为什么能查的快？为什么而需要索引？索引的优缺点？

**使用索引原因：**

数据在磁盘上是以块的形式存储的。为确保对磁盘操作的原子性，访问数据的时候会一并访问所有数据块。磁盘上的这些数据块与链表类似，即它们都包含一个数据段和一个指针，指针指向下一个节点（数据块）的内存地址，而且它们都不需要连续存储。

当表中有大量记录时，若要对表进行查询，第一种搜索信息方式是全表搜索，是将所有记录一一取出，和查询条件进行一一对比，然后返回满足条件的记录，这样做会消耗大量数据库系统时间，并造成大量磁盘I/O操作；第二种就是在表中建立索引，然后在索引中找到符合查询条件的索引值，最后通过保存在索引中的ROWID（相当于页码）快速找到表中对应的记录。

**优点：**
1. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
2. 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
3. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
4. 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
5. 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

**缺点：**
1. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
2. 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
3. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

### 19、索引的底层使用什么实现的，为什么不用B树或者红黑树？

**底层实现：**
B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有Data域。Mysql通过磁盘IO次数来衡量查询效率

B-树/B+树的特点就是每层节点数目非常多，层数很少，目的就是为了就少磁盘IO次数，但是B-树的每个节点都有data域（指针），这无疑增大了节点大小，说白了增加了磁盘IO次数（磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时），而B+树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。这是优点之一。

另一个优点是： B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串起来。这样遍历叶子节点就能获得全部数据，这样就能进行区间访问啦。在数据库中基于范围的查询是非常频繁的，而B树不支持这样的遍历操作。

AVL树和红黑树基本都是存储在内存中才会使用的数据结构。在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。为什么会出现这样的情况，我们知道要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据磁盘查找存取的次数往往由树的高度所决定，所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树可以有多个子女，从几十到上千，可以降低树的高度

### 20、redo？undo？checkpoint？

[参考](https://zhuanlan.zhihu.com/p/34650908)

数据库数据存放的文件称为data file；日志文件称为log file；数据库数据是有缓存的，如果没有缓存，每次都写或者读物理disk，那性能就太低下了。数据库数据的缓存称为data buffer，日志（redo）缓存称为log buffer；既然数据库数据有缓存，就很难保证缓存数据（脏数据）与磁盘数据的一致性。
* undo 
undo日志用于记录事务开始前的状态，用于事务失败时的回滚操作；
* redo
redo日志记录事务执行后的状态，用来恢复未写入data file的已成功事务更新的数据。
* 举例
例如某一事务的事务序号为T1，其对数据X进行修改，设X的原值是5，修改后的值为15，那么Undo日志为<T1, X, 5>，Redo日志为<T1, X, 15>

梳理下事务执行的各个阶段：
1. 写undo日志到log buffer；
2. 执行事务，并写redo日志到log buffer；
3. 如果innodb_flush_log_at_trx_commit=1，则将redo日志写到log file，并刷新落盘。
4. 提交事务。
* 为什么没有写data file，事务就提交了？
因为data buffer中的数据会在合适的时间由存储引擎写入到data file，如果在写入之前，数据库宕机了，根据落盘的redo日志，完全可以将事务更改的数据恢复。先持久化日志的策略叫做Write Ahead Log，即预写日志。

* checkpoint
checkpoint是为了定期将db buffer的内容刷新到data file。当遇到内存不足、db buffer已满等情况时，需要将db buffer中的内容/部分内容（特别是脏数据）转储到data file中。在转储时，会记录checkpoint发生的”时刻“。在故障回复时候，只需要redo/undo最近的一次checkpoint之后的操作。

### 21、mysql写数据的时候,需要先将数据写到buffer里,再写到磁盘里,万一MySQL这时候突然挂了,怎么办?  
根据checkpoint点执行数据库redo、undo操作

### 22、where和 having by 区别 

* Where是一个约束声明，是在结果返回之前起作用的，且Where中不能使用聚合函数
* Having是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，在Having中可以使用聚合函数

### 23、树总结

**共同点：**

1. 都是动态结构。在删除，插入操作的时候，都不需要彻底重建原始的索引树。最多就是执行一定量的旋转，变色操作来有限的改变树的形态。而这些操作所付出的代价都远远小于重建一棵树
2. 查找的时间复杂度大体维持在O(log(N))数量级上。可能有些结构在最差的情况下效率将会下降很快，比如BST

**二叉查找树(BST)：**
1. 性质：
   1. 若左子树不空，则左子树上所有结点的值均小于它的根结点的值； 
   2. 若右子树不空，则右子树上所有结点的值均大于它的根结点的值； 
   3. 左、右子树也分别为二叉排序树； 
   4. 没有键值相等的节点
2. 效率总结：
   1. 查找最好时间复杂度O(logN)，最坏时间复杂度O(N)；
   2. 插入删除操作算法简单，时间复杂度与查找差不多。
3. 缺点：最差情况下竟然和顺序查找效率相当

**平衡二叉查找树(AVL)：**

1. 概念：

   它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

2. 效率总结：
   1. 查找的时间复杂度维持在O(logN)，不会出现最差情况
   2. AVL树在执行每个插入操作时最多需要1次旋转，其时间复杂度在O(logN)左右。
   3. AVL树在执行删除时代价稍大，执行每个删除操作的时间复杂度需要O(2logN)。
3. 缺点：二叉平衡树的严格平衡策略以牺牲建立查找结构(插入，删除操作)的代价，换来了稳定的O(logN)的查找时间复杂度

**红黑树(RBT)：**

1. 效率总结：
   1. 查找效率最好情况下时间复杂度为O(logN)，但在最坏情况下比AVL要差一些，但也远远好于BST，这是由于红黑树的性质最长路径长度不超过最短路径长度的2倍决定的。
   2. 插入和删除操作改变树的平衡性的概率要远远小于AVL（RBT不是高度平衡的）。因此需要的旋转操作的可能性要小，而且一旦需要旋转，插入一个结点最多只需要旋转2次，删除最多只需要旋转3次(小于AVL的删除操作所需要的旋转次数)。虽然变色操作的时间复杂度在O(logN)，但是实际上，这种操作由于简单所需要的代价很小。
2. 缺点：大量数据存储中，实现查询这样一个实际背景下，由于树深度过大而造成磁盘IO读写过于频繁，进而导致效率低下

**B-树（B树）：**

1. 性质(m叉树)：
   1. 树中每个结点至多有m个孩子；
   2. 除根结点和叶子结点外，其它每个结点至少有[m/2]个孩子；
   3. 若根结点不是叶子结点，则至少有2个孩子；
   4. 所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息；
   5. 每个非终端结点中包含有n个关键字信息： (n，A0，K1，A1，K2，A2，......，Kn，An)。其中，
a) Ki (i=1...n)为关键字，且关键字按顺序排序Ki < K(i-1)；  
b) Ai为指向子树根的接点，且指针A(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)； 
c) 关键字的个数n必须满足：[m/2]-1 <= n <= m-1

2. B树的查找：

   与二叉搜索树相似，但不是两路分支。他的查找分为两个基本的操作。
   1. 在B树中找结点；
   2. 在结点内找关键字。由于B树常存储在磁盘中，则前一个查找是在磁盘中进行的，而后一个查找是在内存中进行的，即找到目标结点后，将其读入内存，然后采用顺序或折半查找法查找等于k的关键字。这是一个内存与外存的交叉过程。
3. 效率总结：
由于考虑磁盘储存结构，B树的查找、删除、插入的代价都远远要小于任何二叉结构树(读写磁盘次数的降低)
4. 缺点：在B数中我们不经要遍历节点，还要对每个节点中的关键字进行遍历，这样非常的糟糕，所以引入了B+树

**B+树：**

1. 性质：
其定义基本与B-树同，除了：
   1. 有n棵子树的结点中含有n个关键字；(B树是n棵子树有n+1个关键字)
   2. 所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接
2. 与B树比较：
   1. B+树比B树更适合实际应用中操作系统的文件索引和数据库索引原因：B+树的磁盘读写代价更低；B+树的查询效率更加稳定
   2. B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引，而B树则常用于文件索引。B树由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。

[各种树概念](https://blog.csdn.net/qq_17612199/article/details/50944413)

[动态查找树比较](https://www.iteye.com/topic/614070)

[B+、B-树](https://hxraid.iteye.com/blog/611105)

## 3、JDBC进阶
### 1、JDBC的反射，反射都是什么？
### 2、Jdo是什么?
### 3、Statement和PreparedStatement有什么区别？哪个性能更好？
### 4、使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？



