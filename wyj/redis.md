<!-- TOC -->

- [**Redis + 分布式**](#redis--分布式)
  - [**一、redis 基础知识**](#一redis-基础知识)
    - [1. 使用 redis 原因？redis 的好处？](#1-使用-redis-原因redis-的好处)
    - [2. redis 数据类型](#2-redis-数据类型)
    - [3. redis 和 memcached 的区别？为什么不用 memcached？](#3-redis-和-memcached-的区别为什么不用-memcached)
    - [4. redis 持久化方案](#4-redis-持久化方案)
    - [5. redis 底层如何实现](#5-redis-底层如何实现)
    - [6. redis 如何实现数据的同步与更新？](#6-redis-如何实现数据的同步与更新)
    - [7. 为什么 redis 需要把所有数据放到内存中？](#7-为什么-redis-需要把所有数据放到内存中)
    - [8. redis 常见性能问题和解决方案](#8-redis-常见性能问题和解决方案)
    - [9. redis 数据淘汰策略？mySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据？](#9-redis-数据淘汰策略mysql-里有-2000w-数据redis-中只存-20w-的数据如何保证-redis-中的数据都是热点数据)
    - [10. redis 使用场景](#10-redis-使用场景)
  - [**二、分布式基础知识**](#二分布式基础知识)
    - [1、分布式概念](#1分布式概念)
    - [2、分布式锁](#2分布式锁)

<!-- /TOC -->

# **Redis + 分布式**

## **一、redis 基础知识**

[redis 面试总结](https://www.cnblogs.com/jiahaoJAVA/p/6244278.html)

[redis 详解（三）-- 面试题](https://blog.csdn.net/guchuanyun111/article/details/52064870)

### 1. 使用 redis 原因？redis 的好处？

- 基于 redis 的特性：

1. 性能极高：Redis 是基于内存的，故此具有较高的读写频率。（能支持超过 100K+ 每秒的）
2. 丰富的数据类型：Redis 可以存储键和五种不同类型的值之间的映射，键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。
3. 原子性：Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作全并后的原子性执行
4. 丰富的特性：Redis 还支持发布订阅（publish/subscribe）， 通知， 键的过期时间等特性
5. 支持数据的持久化。redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave(主从)同步

- 基于项目：

  首页是系统的门户，也就是系统的入口，所以首页的访问量是这个系统最大的。如果每次展示首页都从数据库中查询首页的内容信息，那么势必会对数据库造成很大的压力，所以需要使用缓存来减轻数据库压力，redis 可以较好的实现缓存

Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上

### 2. redis 数据类型

Redis 支持五种数据类型：string（字符串），list（列表），set（集合），hash（哈希）及 zset(sorted set：有序集合)。redis 中的数据都是字符串，redis 是单线程，不适合存储比较大的数据

- string：存储字符串、整数、浮点数

  1. 设置值：`set key value`
  2. 获取值：`get key`
  3. 删除键值：`del key`
  4. 值加一：`incr key`
  5. 值减一：`decr key`

- list：数据结构中的：双链表+队列，
  可作为链表 ，从左添加元素 也可以从右添加元素

  1. 从右边添加元素: `rpush listKey value1 value2 ... valueN`
  2. 从左边添加元素: `lpush listKey value1 value2 ... valueN`
  3. 获取指定范围内元素：`lrange listKey 0 -1`（-1 代表最后一个元素，-2 代表倒数第二个元素，以此类推）
  4. 从左边取值，删除：`lpop listKey`
  5. 从右边取值，删除：`rpop listKey`

- set：无顺序，不能重复，集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)

  1. 添加元素：`sadd setKey value1 value2 ... valueN`
  2. 查询元素：`smembers setKey`
  3. 删除元素：`srem keySet value`

- hash：相当于一个 key 对应一个 map (map 中又是 key-value)

  1. 设置值：`hset hashKey sub-key value`
  2. 获取值：`hget hashKey sub-key`
  3. 获取所有值：`hgetall hashKey`
  4. 删除值：`hdel hashKey sub-key`

- zset：有顺序，不能重复
  1. 添加元素： `zadd key score1 member1 [score2 member2]`
  2. 查看分数：
     1. 从小到大：`zrange key 0 -1 [withscores]`：
     2. 从大到小：`zrevrange key 0 -1 [withscores]`
  3. 对元素 member 增加 score：`zincrby key score member`

### 3. redis 和 memcached 的区别？为什么不用 memcached？

1. 数据类型：Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。
2. 数据持久化：Redis 支持 RDB 快照和 AOF 日志两种持久化策略，而 Memcached 不支持持久化。
3. 分布式：Memcached 不支持分布式，Redis Cluster 实现了分布式的支持。
4. 内存管理机制：
   1. 在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。
   2. Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高。

### 4. redis 持久化方案

Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。redis 默认开启 RDB，同时开启两个持久化方案，则按照 AOF 的持久化放案恢复数据。

1. RDB 快照：

   定期将当前时刻的数据保存磁盘中，会产生一个 dump.rdb 文件。特点是会存在数据丢失，性能较好，可以用于数据备份。

2. AOF 日志

   所有对 redis 的操作命令记录在 aof 文件中，恢复数据时重新执行一遍即可。特点是每秒保存，数据比较完整，耗费性能。

   AOF 开启设置：修改 redis.conf 文件，将 appendonly 设置为 yes，数据存在 appendonly.aof 文件中

### 5. redis 底层如何实现

Redis 内部维护一个 db 数组，每个 db 都是一个数据库，默认情况下 Redis 会创建 16 个数据库。我们可以通过 select 命令来切换数据库，如 select 1 切换到数据库号为 1 的数据库。select 实现是通过修改客户端的 db 指针，通过指针指向不同的数据库来实现数据库的切换操作的。

![](https://ws1.sinaimg.cn/large/d4556b75gy1g3yeo8ewlpj209l0ddq3a.jpg)

### 6. redis 如何实现数据的同步与更新？

每次在键空间读取一个键之后，服务器会更新键的 LRU 时间，用于计算键的闲置时间。如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行后续操作。如果有客户端使用 watch 命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为 dirty，从而让事务注意到这个键被修改过。服务器每次修改一个键之后，都会对键计数器的值+1，这个计数器用来触发服务器的持久化操作。如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知。

### 7. 为什么 redis 需要把所有数据放到内存中？

Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以 redis 具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘 I/O 速度为严重影响 redis 的性能。在内存越来越便宜的今天，redis 将会越来越受欢迎。
如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。

### 8. redis 常见性能问题和解决方案

1. Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件。因为 Master 写内存快照，save 命令调度 rdbSave 函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的
2. 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次
3. 为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网内
4. 尽量避免在压力很大的主库上增加从库
5. 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <- Slave3...。这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可以立刻启用 Slave1 做 Master，其他不变。

### 9. redis 数据淘汰策略？mySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据？

可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。Reids 具体有 6 种淘汰策略：

|       策略        |                         描述                         |
| :---------------: | :--------------------------------------------------: |
|  `volatile-lru`   | 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 |
|  `volatile-ttl`   |   从已设置过期时间的数据集中挑选将要过期的数据淘汰   |
| `volatile-random` |      从已设置过期时间的数据集中任意选择数据淘汰      |
|   `allkeys-lru`   |       从所有数据集中挑选最近最少使用的数据淘汰       |
| `allkeys-random`  |          从所有数据集中任意选择数据进行淘汰          |
|   `noeviction`    |                     禁止驱逐数据                     |

限定 Redis 占用的内存，Redis 会根据自身数据淘汰策略，留下热数据到内存。所以，计算一下 20W 数据大约占用的内存，然后设置一下 Redis 内存限制即可，并将淘汰策略为 `volatile-lru` 或者 `allkeys-lru`。

为了提高缓存命中率，保证缓存数据都是热点数据，可以修改 redis 配置文件 redis.conf，将内存最大使用量设置为热点数据占用的内存量，配置指令为 `maxmemory`，然后启用 `allkeys-lru` 淘汰策略，将最近最少使用的数据淘汰，配置指令为`maxmemory-policy`

### 10. redis 使用场景

**1. 计数器**

MySQL 等累加往往扛不住高并发，所以需要原子性操作的 redis 来统计数量，例如统计点击数。可以对 String 进行自增自减运算，从而实现计数器功能。

**2. 缓存**

将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。

**3. 消息队列**

List 是一个双向链表，可以通过 lpop 和 lpush 写入和读取消息。
不过最好使用 Kafka、RabbitMQ 等消息中间件。

由于 redis 把数据添加到队列是返回添加元素在队列的第几位，所以可以做判断用户是第几个访问这种业务的场景。

**4. 分布式锁的实现**

在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。
可以使用 Reids 自带的 `SETNX` 命令实现分布式锁，除此之外，还可以使用官方提供的 `RedLock` 分布式锁实现。

**5. 其它**

Set 可以实现交集、并集等操作，从而实现共同好友等功能。
ZSet 可以实现有序性操作，从而实现排行榜等功能。

## **二、分布式基础知识**

### 1、分布式概念

分布式结构就是将一个完整的系统，按照业务功能，拆分成一个个独立的子系统，在分布式结构中，每个子系统就被称为“服务”。这些子系统能够独立运行在 web 容器中，它们之间通过 RPC 方式通信。

### 2、分布式锁

[分布式锁入门以及三种实现方式](https://app.yinxiang.com/fx/b38ebbb8-5c1c-48d6-b172-770de099b756)

**实现方式：**

- 基于数据库实现分布式锁

  在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。

  缺点：锁没有失效时间，不可重入

- 基于 redis 实现

  使用 Redis 实现分布式锁的时候，主要会使用到三个命令：

  > SETNX key val

  当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0;类似于数据库的唯一索引。

  > expire key timeout

  为 key 设置一个过期时间，单位为 second，超过这个时间锁会自动释放，避免死锁。避免数据库唯一索引实现方式中释放锁失败的问题。

  > delete key

  删除 key。

  **思想：**

  1. 获取锁的时候，使用 setnx 加锁，并使用 expire 命令为锁添加一个过期时间，超过该时间则自动释放锁，锁的 value 值为一个随机生成的 UUID，通过此在释放锁的时候进行判断。
  2. 获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。
  3. 释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。

- 基于 ZooKeeper 的实现方式
