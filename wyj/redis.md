<!-- TOC -->

- [一、redis 基础知识](#一redis-基础知识)
  - [使用 redis 原因？redis 的好处？](#使用-redis-原因redis-的好处)
  - [Redis 集群](#redis-集群)
  - [redis 数据类型](#redis-数据类型)
  - [redis 和 memcached 的区别？为什么不用 memcached？](#redis-和-memcached-的区别为什么不用-memcached)
  - [redis 持久化方案](#redis-持久化方案)
  - [redis 底层如何实现，Redis 的高并发和快速原因](#redis-底层如何实现redis-的高并发和快速原因)
  - [redis 如何实现数据的同步与更新？](#redis-如何实现数据的同步与更新)
  - [为什么 redis 需要把所有数据放到内存中？](#为什么-redis-需要把所有数据放到内存中)
  - [redis 常见性能问题和解决方案](#redis-常见性能问题和解决方案)
  - [Redis 并发竞争问题以及解决方案](#redis-并发竞争问题以及解决方案)
  - [redis 数据淘汰策略？mySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据？](#redis-数据淘汰策略mysql-里有-2000w-数据redis-中只存-20w-的数据如何保证-redis-中的数据都是热点数据)
  - [Redis 高级事务](#redis-高级事务)
  - [如何判断 Redis 里面的缓存添加成功了](#如何判断-redis-里面的缓存添加成功了)
  - [Redis 缓存(Redis)和数据库（MySQL）间的数据一致性](#redis-缓存redis和数据库mysql间的数据一致性)
  - [Redis 使用场景](#redis-使用场景)
- [ActiveMQ](#activemq)
  - [如何保证消息不被重复消费](#如何保证消息不被重复消费)
- [](#)
- [二、分布式基础知识](#二分布式基础知识)
  - [分布式概念](#分布式概念)
  - [分布式锁](#分布式锁)

<!-- /TOC -->

# 一、redis 基础知识

[redis 面试总结](https://www.cnblogs.com/jiahaoJAVA/p/6244278.html)

[redis 详解（三）-- 面试题](https://blog.csdn.net/guchuanyun111/article/details/52064870)

## 使用 redis 原因？redis 的好处？

- 基于 redis 的特性：

1. 性能极高：Redis 是基于内存的，故此具有较高的读写频率。（能支持超过每秒 10 万次读写操作）
2. 丰富的数据类型：Redis 可以存储键和五种不同类型的值之间的映射，键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。
3. 原子性：Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作全并后的原子性执行
4. 丰富的特性：Redis 还支持发布订阅（publish/subscribe）， 通知， 键的过期时间等特性
5. 支持数据的持久化。redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave(主从)同步

- 基于项目：

  首页是系统的门户，也就是系统的入口，所以首页的访问量是这个系统最大的。如果每次展示首页都从数据库中查询首页的内容信息，那么势必会对数据库造成很大的压力，所以需要使用缓存来减轻数据库压力，redis 可以较好的实现缓存

Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上

Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。

## Redis 集群

- Redis 3.0 之后开始支持集群
- Redis 集群没有统一的入口，客户端连接集群的时候连接集群中的任意节点即可，集群内部是通过 ping-pong 机制互相通信的

判断 Redis 集群是否挂掉方式:

1. Redis 集群有一个投票容错机制，如果集群中超过半数的节点投票认为某个结点挂了，那么这个结点就挂了
2. 判断 Redis 集群是否挂了：如果集群中任意一个结点挂了，而且这个结点没有从结点 slave，那么这个集群就挂了，原因是：  
   集群里内置了 16384 个 slot（哈希槽），并且把所有的物理结点都映射到这 16384 个 slot 上（0~16383），当 Redis 集群中存放一个数据时，Redis 会先对这个 key 进行 crc16 算法，然后得到一个结果对 16384 进行求余，从而决定这个结点存储到那个结点中。所有一旦某一个节点挂了，该节点得 slot 就无法使用了。

## redis 数据类型

Redis 支持五种数据类型：string（字符串），list（列表），set（集合），hash（哈希）及 zset(sorted set：有序集合)。redis 中的数据都是字符串，redis 是单线程，不适合存储比较大的数据

- string：存储字符串、整数、浮点数

  1. 设置值：`set key value`
  2. 获取值：`get key`
  3. 删除键值：`del key`
  4. 值加一：`incr key`
  5. 值减一：`decr key`

- list：数据结构中的：双链表+队列，
  可作为链表 ，从左添加元素 也可以从右添加元素

  1. 从右边添加元素: `rpush listKey value1 value2 ... valueN`
  2. 从左边添加元素: `lpush listKey value1 value2 ... valueN`
  3. 获取指定范围内元素：`lrange listKey 0 -1`（-1 代表最后一个元素，-2 代表倒数第二个元素，以此类推）
  4. 从左边取值，删除：`lpop listKey`
  5. 从右边取值，删除：`rpop listKey`

- set：无顺序，不能重复，集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)

  1. 添加元素：`sadd setKey value1 value2 ... valueN`
  2. 查询元素：`smembers setKey`
  3. 删除元素：`srem keySet value`

- hash：相当于一个 key 对应一个 map (map 中又是 key-value)

  1. 设置值：`hset hashKey sub-key value`
  2. 获取值：`hget hashKey sub-key`
  3. 获取所有值：`hgetall hashKey`
  4. 删除值：`hdel hashKey sub-key`

- zset：有顺序，不能重复
  1. 添加元素： `zadd key score1 member1 [score2 member2]`
  2. 查看分数：
     1. 从小到大：`zrange key 0 -1 [withscores]`：
     2. 从大到小：`zrevrange key 0 -1 [withscores]`
  3. 对元素 member 增加 score：`zincrby key score member`

## redis 和 memcached 的区别？为什么不用 memcached？

1. 数据类型：Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。
2. 数据持久化：Redis 支持 RDB 快照和 AOF 日志两种持久化策略，而 Memcached 不支持持久化。
3. 分布式：Memcached 不支持分布式，Redis Cluster 实现了分布式的支持。
4. 内存管理机制：
   1. 在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。
   2. Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高。

## redis 持久化方案

Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。redis 默认开启 RDB，同时开启两个持久化方案，则按照 AOF 的持久化放案恢复数据。

1. RDB 快照：

   定期将当前时刻的数据保存磁盘中，会产生一个 dump.rdb 文件。特点是会存在数据丢失，性能较好，可以用于数据备份。

2. AOF 日志

   所有对 redis 的操作命令记录在 aof 文件中，恢复数据时重新执行一遍即可。特点是每秒保存，数据比较完整，耗费性能。

   AOF 开启设置：修改 redis.conf 文件，将 appendonly 设置为 yes，数据存在 appendonly.aof 文件中

## redis 底层如何实现，Redis 的高并发和快速原因

Redis 内部维护一个 db 数组，每个 db 都是一个数据库，默认情况下 Redis 会创建 16 个数据库。我们可以通过 select 命令来切换数据库，如 select 1 切换到数据库号为 1 的数据库。select 实现是通过修改客户端的 db 指针，通过指针指向不同的数据库来实现数据库的切换操作的。

![image](https://ws1.sinaimg.cn/large/d4556b75gy1g3yeo8ewlpj209l0ddq3a.jpg)

Redis 的高并发和快速原因：

1. redis 是基于内存的，内存的读写速度非常快；
2. redis 是单线程的，省去了很多上下文切换线程的时间，不存在加锁释放锁操作，因为不会出现因为死锁而导致的性能消耗。
3. redis 使用多路复用技术，Redis 使用 I/O 多路复用程序来监听多个套接字，并将到达的事件发送给文件事件分派器，分配器根据套接字产生的事件类型调用相应的事件处理器

   Redis 将所有的文件事件（读、写、异常）放在一个无序链表中，通过遍历查找已经到达的时间事件，并调用相应的事件处理器。

   多路指的是多个 Socket 连接，复用指的是复用一个线程。

   ![image](http://ww1.sinaimg.cn/large/d4556b75ly1g5xtjvdxcjj20q80aqaaq.jpg)

## redis 如何实现数据的同步与更新？

每次在键空间读取一个键之后，服务器会更新键的 LRU 时间，用于计算键的闲置时间。如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行后续操作。如果有客户端使用 watch 命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为 dirty，从而让事务注意到这个键被修改过。服务器每次修改一个键之后，都会对键计数器的值+1，这个计数器用来触发服务器的持久化操作。如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知。

## 为什么 redis 需要把所有数据放到内存中？

Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以 redis 具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘 I/O 速度为严重影响 redis 的性能。在内存越来越便宜的今天，redis 将会越来越受欢迎。
如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。

## redis 常见性能问题和解决方案

1. Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件。因为 Master 写内存快照，save 命令调度 rdbSave 函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的
2. 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次
3. 为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网内
4. 尽量避免在压力很大的主库上增加从库
5. 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <- Slave3...。这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可以立刻启用 Slave1 做 Master，其他不变。

## Redis 并发竞争问题以及解决方案

Redis 为单进程单线程模式。采用并发模式将并发访问变为串行访问，因为本身没有锁的概念，所以并不存在资源竞争问题，但是在 Jedis 客户端对 Redis 并发访问会出现连接超时、数据转化错误、阻塞以及客户端关闭连接等问题。

解决方案：

1. 客户端：对连接进行池化，同时对客户端读写 Redis 操作使用内部锁 `synchronized`

## redis 数据淘汰策略？mySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据？

可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。Reids 具体有 6 种淘汰策略：

|       策略        |                         描述                         |
| :---------------: | :--------------------------------------------------: |
|  `volatile-lru`   | 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 |
|  `volatile-ttl`   |   从已设置过期时间的数据集中挑选将要过期的数据淘汰   |
| `volatile-random` |      从已设置过期时间的数据集中任意选择数据淘汰      |
|   `allkeys-lru`   |       从所有数据集中挑选最近最少使用的数据淘汰       |
| `allkeys-random`  |          从所有数据集中任意选择数据进行淘汰          |
|   `noeviction`    |                     禁止驱逐数据                     |

限定 Redis 占用的内存，Redis 会根据自身数据淘汰策略，留下热数据到内存。所以，计算一下 20W 数据大约占用的内存，然后设置一下 Redis 内存限制即可，并将淘汰策略为 `volatile-lru` 或者 `allkeys-lru`。

为了提高缓存命中率，保证缓存数据都是热点数据，可以修改 redis 配置文件 redis.conf，将内存最大使用量设置为热点数据占用的内存量，配置指令为 `maxmemory`，然后启用 `allkeys-lru` 淘汰策略，将最近最少使用的数据淘汰，配置指令为`maxmemory-policy`

## Redis 高级事务

## 如何判断 Redis 里面的缓存添加成功了

添加缓存加入判断机制

## Redis 缓存(Redis)和数据库（MySQL）间的数据一致性

[Redis 和 mysql 数据怎么保持数据一致的？](https://blog.csdn.net/weixin_45132238/article/details/93490308)

[分布式之数据库和缓存双写一致性方案解析](https://www.cnblogs.com/rjzheng/p/9041659.html)

不管是先写 MySQL 数据库，再删除 Redis 缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。

**方案 1：延时双删策略+设置缓存过期时间**

具体做法：

- 先删除缓存
- 再写数据库
- 休眠 500 毫秒
- 再次删除缓存

休眠的原因是可以将休眠期间造成的脏数据再次删除。休眠时间要结合项目的读数据业务逻辑的耗时，然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百 ms 即可。这么做的目的，就是**确保读请求结束，写请求可以删除读请求造成的缓存脏数据**。

设置缓存过期时间从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。

缺点：结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。

## Redis 使用场景

**1. 计数器**

MySQL 等累加往往扛不住高并发，所以需要原子性操作的 redis 来统计数量，例如统计点击数。可以对 String 进行自增自减运算，从而实现计数器功能。

**2. 缓存**

将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。

**3. 消息队列**

List 是一个双向链表，可以通过 lpop 和 lpush 写入和读取消息。
不过最好使用 Kafka、RabbitMQ 等消息中间件。

由于 redis 把数据添加到队列是返回添加元素在队列的第几位，所以可以做判断用户是第几个访问这种业务的场景。

**4. 分布式锁的实现**

在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。
可以使用 Reids 自带的 `SETNX` 命令实现分布式锁，除此之外，还可以使用官方提供的 `RedLock` 分布式锁实现。

**5. 其它**

Set 可以实现交集、并集等操作，从而实现共同好友等功能。
ZSet 可以实现有序性操作，从而实现排行榜等功能。

# ActiveMQ

## 如何保证消息不被重复消费

##

# 二、分布式基础知识

## 分布式概念

分布式结构就是将一个完整的系统，按照业务功能，拆分成一个个独立的子系统，在分布式结构中，每个子系统就被称为“服务”。这些子系统能够独立运行在 web 容器中，它们之间通过 RPC 方式通信。

## 分布式锁

[分布式锁入门以及三种实现方式](https://app.yinxiang.com/fx/b38ebbb8-5c1c-48d6-b172-770de099b756)

**实现方式：**

- 基于数据库实现分布式锁

  在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。

  缺点：锁没有失效时间，不可重入

- 基于 redis 实现

  使用 Redis 实现分布式锁的时候，主要会使用到三个命令：

  > SETNX key val

  当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0；类似于数据库的唯一索引。

  > expire key timeout

  为 key 设置一个过期时间，单位为 second，超过这个时间锁会自动释放，避免死锁。避免数据库唯一索引实现方式中释放锁失败的问题。

  > delete key

  删除 key。

  **思想：**

  1. 获取锁的时候，使用 setnx 加锁，并使用 expire 命令为锁添加一个过期时间，超过该时间则自动释放锁，锁的 value 值为一个随机生成的 UUID，通过此在释放锁的时候进行判断。
  2. 获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。
  3. 释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。

- 基于 ZooKeeper 的实现方式
